package org.psring.leetcode.practive;
/**
 * 贪心的算法：->举出了反例，是不正确的
 *
 * 最直观的转移方程：
 *
 * dp[i]: 代表到key[i]为止，拼接所需要的最少步数
 * dp[i-1]: 到key[i - 1]为止，拼接所需要的最少步数
 *
 * dp[i] = dp[i - 1] + (从key[i-1]到key[i]在圆盘上所要走的最短距离) + 1 （按button需要的步数为1）
 *
 * 下标x和下标y在圆盘上的最短距离： |x - y| 或者 n - |x - y|
 * 即Math.min(Math.abs(x - y), n - Math.abs(x - y))
 *
 * 但是，
 * key[i-1] 在圆盘上可以出现多次
 * key[i] 在圆盘上可以出现多次
 * 因此一个维度是不够的，再增加一个维度
 *
 * 定义转移方程：
 * dp[i][j] 代表到key[i]为止拼接所需要的最少步数，
 * 并且这个key[i]是第j个在圆盘上出现的key[i]
 *
 * 比如说key[i] = 'd'，在ring圆盘上出现位置的下标：2, 7, 8
 * dp[i][0] 代表到key[i]为止拼接所需要的最少步数，并且这个key[i]是位于下标位置为2的key[i]
 * dp[i][1] 代表到key[i]为止拼接所需要的最少步数，并且这个key[i]是位于下标位置为7的key[i]
 * ...以此类推
 *
 * 上一个字符是key[i-1] = 'a'，在ring圆盘上出现的位置下标是: 4, 9
 * dp[i][0] 代表到key[i - 1]为止拼接所需要的最少步数，并且这个key[i - 1]是位于下标位置为4的key[i]
 * dp[i][1] 代表到key[i - 1]为止拼接所需要的最少步数，并且这个key[i - 1]是位于下标位置为9的key[i]
 *
 * dp[i][j] =
 * Math.min(
 * dp[i-1][0] + 上一个字符key[i-1]（第0个出现的key[i - 1]）到这一个字符key[i]（第j个出现的key[i]）的最短距离,
 * dp[i-1][1] + 上一个字符key[i-1]（第1个出现的key[i - 1]）到这一个字符key[i]（第j个出现的key[i]）的最短距离,
 * ....
 * dp[i-1][k] + 上一个字符key[i-1]（第k个出现的key[i - 1]）到这一个字符key[i]（第j个出现的key[i]）的最短距离,
 * )  + 1 (按button的步数为1)
 * */
public class FreeRoad {

}
